<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=Edge"/>
        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=0" />
        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black" />
        <meta name="format-detection" content="telephone=no" /> 
        <meta name="format-detection" content="email=no" />
        <meta name="keywords" content="" />
        <meta name="description" content="" />
        <title>Base</title>
        <style type="text/css">
            body {
                background-color:#bbb;
            }
            #canvas{
                background-color:#fff;
            }
        </style>
    </head>
    <body>

        <canvas id="canvas" width="500" height="500">You browser do not support canvas</canvas>
    
        <script type="text/javascript" src="./js/utils.js"></script>
        <script type="text/javascript" src="./js/draws.js"></script>
        <script type="text/javascript">
            window.onload=function(){
                var canvas = document.getElementById("canvas");
                var ctx = canvas.getContext("2d");
                var mouse = utils.captureMouse(canvas);
                var touch = utils.captureTouch(canvas);

                (function drawFrame(){
                    // window.requestAnimationFrame(drawFrame);
                    // ctx.clearRect(0,0,canvas.width,canvas.height);

                    // radians = degrees * Math.PI / 180;
                    // degrees = radians * 180 / Math.PI;

                    // var dx = x2 - x1;
                    // var dy = y2 - y1;
                    // var dist = Math.sqrt(dx*dx + dy*dy);

                    // 简单坐标旋转
                    // dx = ball.x - centerX;
                    // dy = ball.y - centerY;
                    // angle = Math.atan2(dy, dx);
                    // radius = Math.sqrt(dx * dx + dy * dy);
                    // ball.x = centerX + Math.cos(angle) * radius;
                    // ball.y = centerY + Math.sin(angle) * radius;

                    // 高级坐标旋转
                    // x = ball.x - centerX;
                    // y = ball.y - centerY;
                    // x1 = x * cos(rotation) - y * sin(rotation);
                    // y1 = y * cos(rotation) + x * sin(rotation);
                    // ball.x = centerX + x1;
                    // ball.y = centerY + y1;

                    // 反向坐标旋转
                    // x1 = x * cos(rotation) + y * sin(rotation);
                    // y1 = y * cos(rotation) - x * sin(rotation);

                    // 动量方程
                    // p = m * v;

                    // 动能方程
                    // KE = 0.5 * m * v * v;

                    // m0 * v0 + m1 * v1 = m0 * v0Final + m1 * v1Final;
                    // 0.5 * m0 * v0 * v0 + 0.5 * m1 * v1 * v1 = 0.5 * m0 * v0Final * v0Final + 0.5 * m1 * v1Final * v1Final;
                    // v0Final = ((m0 - m1) * v0 + 2 * m1 * v1 ) / (m0 + m1);
                    // v1Final = ((m1 - m0) * v1 + 2 * m0 * v0 ) / (m0 + m1);

                    // vxTotal = v0 - v1;
                    // v1Final = v0Final + vxTotal;

                    // 万有引力
                    // force = G * m1 * m2 / distance * distance; G = 6.674 * e-11

                    // 余弦定理
                    // c * c = a * a + b * b - 2 * a * b * cos(C)
                    // B = Math.acos((a*a+c*c-b*b)/(2*a*c));
                    // C = Math.acos((a*a+b*b-c*c)/(2*a*b));

                    // var dx = mouse.x - segment1.x,
                    //     dy = mouse.y - segment1.y,
                    //     dist = Math.sqrt(dx * dx + dy * dy),
                    //     a = 100,
                    //     b = 100,
                    //     c = Math.min(dist, a + b),
                    //     B = Math.acos((a * a + c * c - b * b) / (2 * a * c)),
                    //     C = Math.acos((a * a + b * b - c * c) / (2 * a * b)),
                    //     D = Math.atan2(dy, dx),
                    //     E = D + B + Math.PI + C;
                    // segment1.rotation = D + B;
                    // var target = segment1.getPin();
                    // segment0.x = target.x;
                    // segment0.y = target.y;
                    // segment0.rotation = E;
                    // segment0.draw(context);
                    // segment1.draw(context);

                    // 透视图公式
                    // scale = f1 / (f1 + z)

                    // function checkCollision(ball0, ball1) {
                    //     var dx = ball1.x - ball0.x,
                    //         dy = ball1.y - ball0.y,
                    //         dist = Math.sqrt(dx * dx + dy * dy);
                    //     if(dist < ball0.radius + ball1.radius) {
                    //         var angle = Math.atan2(dy, dx),
                    //             sin = Math.sin(angle),
                    //             cos = Math.cos(angle);
                            
                    //         // rotate ball0's position
                    //         var x0 = 0,
                    //             y0 = 0;
                    //         // rotate ball1's position
                    //         var x1 = dx * cos + dy * sin,
                    //             y1 = dy * cos - dx * sin;
                    //         // rotate ball0's velocity
                    //         var vx0 = ball0.vx * cos + ball0.vy * sin,
                    //             vy0 = ball0.vy * cos - ball0.vx * sin;
                    //         // rotate ball1's velocity
                    //         var vx1 = ball1.vx * cos + ball1.vy * sin,
                    //             vy1 = ball1.vy * cos - ball1.vx * sin;
                    //         // collision reaction
                    //         var vxTotal = vx0 - vx1;
                    //         vx0 = ((ball0.mass - ball1.mass) * vx0 + 2 * ball1.mass * vx1) / (ball0.mass + ball1.mass);
                    //         vx1 = vxTotal + vx0;
                    //         x0 += vx0;
                    //         x1 += vx1;
                    //         // rotate positions back
                    //         var x0Final = x0 * cos - y0 * sin,
                    //             y0Final = y0 * cos + x0 * sin,
                    //             x1Final = x1 * cos - y1 * sin,
                    //             y1Final = y1 * cos + x1 * sin;
                    //         // adjust positions to actual screen positions
                    //         ball1.x = ball0.x + x1Final;
                    //         ball1.y = ball0.y + y1Final;
                    //         ball0.x = ball0.x + x0Final;
                    //         ball0.y = ball0.y + y0Final;
                    //         // rotate velocity back
                    //         ball0.vx = vx0 * cos - vy0 * sin;
                    //         ball0.vy = vy0 * cos + vx0 * sin;
                    //         ball1.vx = vx1 * cos - vy1 * sin;
                    //         ball1.vy = vy1 * cos + vx1 * sin;
                    //     }
                    // }

                    // function rotate(x, y, sin, cos, reverse) {
                    //     return {
                    //         x : (reverse) ? (x * cos + y * sin) : (x * cos - y * sin),
                    //         y : (reverse) ? (y * cos - x * sin) : (y * cos + x * sin)
                    //     };
                    // }

                    // function checkCollision(ball0, ball1) {
                    //     var dx = ball1.x - ball0.x,
                    //         dy = ball1.y - ball0.y,
                    //         dist = Math.sqrt(dx * dx + dy * dy);
                    //     if(dist < ball0.radius + ball1.radius) {
                    //         var angle = Math.atan2(dy, dx),
                    //             sin = Math.sin(angle),
                    //             cos = Math.cos(angle);

                    //             // rotate ball0's position
                    //         var pos0 = {x : 0, y : 0},
                    //             // rotate ball1's position
                    //             pos1 = rotate(dx, dy, sin, cos, true),
                    //             // rotate ball0's velocity
                    //             vel0 = rotate(ball0.vx, ball0.vy, sin, cos, true),
                    //             // rotate ball1's velocity
                    //             vel1 = rotate(ball1.vx, ball1.vy, sin, cos, true);
                            
                    //         // collision reaction
                    //         var vxTotal = vel0.x - vel1.x;
                    //         vel0.x = ((ball0.mass - ball1.mass) * vel0.x + 2 * ball1.mass * vel1.x) / (ball0.mass + ball1.mass);
                    //         vel1.x = vxTotal + vel0.x;
                    //         pos0.x += vel0.x;
                    //         pos1.x += vel1.x;
                    //         // rotate positions back
                    //         var pos0r = rotate(pos0.x, pos0.y, sin, cos, false),
                    //             pos1r = rotate(pos1.x, pos1.y, sin, cos, false);
                    //         // adjust positions to actual screen positions
                    //         ball1.x = ball0.x + pos1r.x;
                    //         ball1.y = ball0.y + pos1r.y;
                    //         ball0.x = ball0.x + pos0r.x;
                    //         ball0.y = ball0.y + pos0r.y;
                    //         // rotate velocity back
                    //         var vel0r = rotate(vel0.x, vel0.y, sin, cos, false),
                    //             vel1r = rotate(vel1.x, vel1.y, sin, cos, false);
                    //         ball0.vx = vel0r.x;
                    //         ball0.vy = vel0r.y;
                    //         ball1.vx = vel1r.x;
                    //         ball1.vy = vel1r.y;
                    //     }
                    // }

                    // function checkWalls(ball) {
                    //     if(ball.x + ball.radius > canvas.width) {
                    //         ball.x = canvas.width - ball.radius;
                    //         ball.vx *= bounce;
                    //     } else if(ball.x - ball.radius < 0) {
                    //         ball.x = ball.radius;
                    //         ball.vx *= bounce;
                    //     }
                    //     if(ball.y + ball.radius > canvas.height) {
                    //         ball.y = canvas.height - ball.radius;
                    //         ball.vy *= bounce;
                    //     } else if(ball.y - ball.radius < 0) {
                    //         ball.y = ball.radius;
                    //         ball.vy *= bounce;
                    //     }
                    // }

                    // function gravitate(partA, partB) {
                    //     var dx = partB.x - partA.x,
                    //         dy = partB.y - partA.y,
                    //         distSQ = dx * dx + dy * dy,
                    //         dist = Math.sqrt(distSQ),
                    //         force = partA.mass * partB.mass / distSQ,
                    //         ax = force * dx / dist,
                    //         ay = force * dy / dist;
                    //     partA.vx += ax / partA.mass;
                    //     partA.vy += ay / partA.mass;
                    //     partB.vx -= ax / partB.mass;
                    //     partB.vy -= ay / partB.mass;
                    // }

                    // function spring(partA, partB) {
                    //     var dx = partB.x - partA.x,
                    //         dy = partB.y - partA.y,
                    //         dist = Math.sqrt(dx * dx + dy * dy);
                    //     if(dist < minDist) {
                    //         var alpha = 1 - dist / minDist;
                    //         context.strokeStyle = utils.colorToRGB('#ffffff', alpha);
                    //         context.beginPath();
                    //         context.moveTo(partA.x, partA.y);
                    //         context.lineTo(partB.x, partB.y);
                    //         context.stroke();

                    //         var ax = dx * springAmount,
                    //             ay = dy * springAmount;
                    //         partA.vx += ax / partA.mass;
                    //         partA.vy += ay / partA.mass;
                    //         partB.vx -= ax / partB.mass;
                    //         partB.vy -= ay / partB.mass;
                    //     }
                    // }

                    // function drag(segment, xpos, ypos) {
                    //     var dx = xpos - segment.x,
                    //         dy = ypos - segment.y;
                        
                    //     segment.rotation = Math.atan2(dy, dx);

                    //     var w = segment.getPin().x - segment.x,
                    //         h = segment.getPin().y - segment.y;
                        
                    //     segment.x = xpos - w;
                    //     segment.y = ypos - h;
                    // }

                    // function reach(segment, xpos, ypos) {
                    //     var dx = xpos - segment.x,
                    //         dy = ypos - segment.y;
                        
                    //     segment.rotation = Math.atan2(dy, dx);

                    //     var w = segment.getPin().x - segment.x,
                    //         h = segment.getPin().y - segment.y;
                        
                    //     return {
                    //         x : xpos - w,
                    //         y : yops - h 
                    //     }
                    // }


                    //- mouse events
                    // function onMouseEvent(event) {
                    //     console.log(event.type + ", mouse.x:" + mouse.x + " mouse.y:" + mouse.y);
                    // }
                    // canvas.addEventListener('mousedown', onMouseEvent, false);
                    // canvas.addEventListener('mouseup', onMouseEvent, false);
                    // canvas.addEventListener('click', onMouseEvent, false);
                    // canvas.addEventListener('dblclick', onMouseEvent, false);
                    // canvas.addEventListener('mousewheel', onMouseEvent, false);
                    // canvas.addEventListener('mousemove', onMouseEvent, false);
                    // canvas.addEventListener('mouseover', onMouseEvent, false);
                    // canvas.addEventListener('mouseout', onMouseEvent, false);

                    //- touch events
                    // function onTouchEvent(event) {
                    //     if(touch.isPressed) {
                    //         console.log(event.type + ", touch.x:" + mouse.x + " touch.y:" + mouse.y);
                    //     }
                    // }
                    // canvas.addEventListener('touchstart', onTouchEvent, false);
                    // canvas.addEventListener('touchend', onTouchEvent, false);
                    // canvas.addEventListener('touchmove', onTouchEvent, false);

                    //- keyboard events
                    // function onKeyboardEvent(event) {
                    //     console.log(event.type);
                    //     switch(event.keyCode) {
                    //         case keycode.UP : console.log('up!');break;
                    //         case keycode.DOWN : console.log('down!');break;
                    //         case keycode.LEFT : console.log('left!');break;
                    //         case keycode.RIGHT : console.log('right!');break;
                    //         default : console.log('keyCode : ' + event.keyCode);
                    //     }
                    // }
                    // window.addEventListener('keydown', onKeyboardEvent, false);
                    // window.addEventListener('keyup', onKeyboardEvent, false);

                    // context.fillStyle = '#000000';
                    // context.fill(); //使用当前的填充样式填充子路径

                    // context.strokeStyle = '#000000'; //线条颜色
                    // context.lineWidth = 1; //线条宽度
                    // context.lineCap = butt || round || square; //线条的终点形状
                    // context.lineJoin = miter || round || bevel; //两条相邻的线段如何接合
                    // context.miterLimit = 10; //当lineJoin属性为miter时，控制两条相交线外侧交点与内侧交点的距离，必须是大于0的有限数

                    // context.save(); //将canvas当前状态存入栈中
                    // context.restore(); //使当前canvas状态出栈转而使用下一个状态，也就是之前的状态

                    // context.beginPath();
                    // context.moveTo(0, 0);
                    // context.lineTo(100, 100);
                    // context.stroke(); //渲染线条

                    // context.quadraticCurveTo(cpx, cpy, x, y); // 控制点坐标，终点坐标，二次贝塞尔曲线
                    // context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y); // 控制点坐标，控制点坐标，终点坐标，三次贝塞尔曲线
                    // context.arcTo(cp1x, cp1y, cp2x, cp2y, radius); //使用两个控制点和指定半径为连接到前一个点的直线路径添加一个弧度
                    // context.arc(x, y, radius, startAngle, endAngle, antiClockwise); //为连接到前一个点的直线路径添加一个弧度

                    // context.createLinearGradient(x0, y0, x1, y1); //线性渐变
                    // context.createRadialGradient(x0, y0, r0, x1, y1, r1); //放射性渐变

                    // var gradient = context.createLinearGradient(0, 0, 100, 100);
                    // gradient.addColorStop(0, "#ffffff");
                    // gradient.addColorStop(1, "#ff0000");
                    // context.fillStyle = gradient;
                    // context.fillRect(0, 0, 100, 100);

                    // context.drawImage(image, dx, dy);
                    // context.drawImage(image, dx, dy, dw, dh);
                    // context.drawImage(image, sx, sy, sw, sh, dx, dy, dw, dh);

                    // //图片需要在同一个域中
                    // var imagedata = context.getImageData(x, y, width, height);
                    // var imagedata = context.createImageData(width, height);
                    // var imagedata = context.createImageData(anotherImageData);
                    // context.putImageData(imagedata, x, y);


                    // 圆弧
                    // for(var i=0;i<4;i++){
                    //     for(var j=0;j<3;j++){
                    //         ctx.beginPath();
                    //         var x              = 25+j*50;               // x 坐标值
                    //         var y              = 25+i*50;               // y 坐标值
                    //         var radius         = 20;                    // 圆弧半径
                    //         var startAngle     = 0;                     // 开始点
                    //         var endAngle       = Math.PI+(Math.PI*j)/2; // 结束点
                    //         var anticlockwise  = i%2==0 ? false : true; // 顺时针或逆时针

                    //         ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise);

                    //         if (i>1){
                    //             ctx.fill();
                    //         } else {
                    //             ctx.stroke();
                    //         }
                    //     }
                    // }

                    // 贝塞尔曲线
                    // ctx.beginPath();
                    // ctx.moveTo(75,25);
                    // ctx.quadraticCurveTo(25,25,25,62.5);
                    // ctx.quadraticCurveTo(25,100,50,100);
                    // ctx.quadraticCurveTo(50,120,30,125);
                    // ctx.quadraticCurveTo(60,120,65,100);
                    // ctx.quadraticCurveTo(125,100,125,62.5);
                    // ctx.quadraticCurveTo(125,25,75,25);
                    // ctx.stroke();

                    // 二次贝塞尔曲线
                    // ctx.beginPath();
                    // ctx.moveTo(75,40);
                    // ctx.bezierCurveTo(75,37,70,25,50,25);
                    // ctx.bezierCurveTo(20,25,20,62.5,20,62.5);
                    // ctx.bezierCurveTo(20,80,40,102,75,120);
                    // ctx.bezierCurveTo(110,102,130,80,130,62.5);
                    // ctx.bezierCurveTo(130,62.5,130,25,100,25);
                    // ctx.bezierCurveTo(85,25,75,37,75,40);
                    // ctx.fill();

                    // ctx.beginPath();
                    // ctx.arc(37,37,13,Math.PI/7,-Math.PI/7,false);
                    // ctx.lineTo(31,37);
                    // ctx.fill();
                    // for(var i=0;i<8;i++){
                    //     ctx.fillRect(51+i*16,35,4,4);
                    // }
                    // for(i=0;i<6;i++){
                    //     ctx.fillRect(115,51+i*16,4,4);
                    // }
                    // for(i=0;i<8;i++){
                    //     ctx.fillRect(51+i*16,99,4,4);
                    // }
                    // ctx.beginPath();
                    // ctx.moveTo(83,116);
                    // ctx.lineTo(83,102);
                    // ctx.bezierCurveTo(83,94,89,88,97,88);
                    // ctx.bezierCurveTo(105,88,111,94,111,102);
                    // ctx.lineTo(111,116);
                    // ctx.lineTo(106.333,111.333);
                    // ctx.lineTo(101.666,116);
                    // ctx.lineTo(97,111.333);
                    // ctx.lineTo(92.333,116);
                    // ctx.lineTo(87.666,111.333);
                    // ctx.lineTo(83,116);
                    // ctx.fill();
                    // ctx.fillStyle = "white";
                    // ctx.beginPath();
                    // ctx.moveTo(91,96);
                    // ctx.bezierCurveTo(88,96,87,99,87,101);
                    // ctx.bezierCurveTo(87,103,88,106,91,106);
                    // ctx.bezierCurveTo(94,106,95,103,95,101);
                    // ctx.bezierCurveTo(95,99,94,96,91,96);
                    // ctx.moveTo(103,96);
                    // ctx.bezierCurveTo(100,96,99,99,99,101);
                    // ctx.bezierCurveTo(99,103,100,106,103,106);
                    // ctx.bezierCurveTo(106,106,107,103,107,101);
                    // ctx.bezierCurveTo(107,99,106,96,103,96);
                    // ctx.fill();
                    // ctx.fillStyle = "black";
                    // ctx.beginPath();
                    // ctx.arc(101,102,2,0,Math.PI*2,true);
                    // ctx.fill();
                    // ctx.beginPath();
                    // ctx.arc(89,102,2,0,Math.PI*2,true);
                    // ctx.fill();


                    // 填充三角形
                    // ctx.beginPath();
                    // ctx.moveTo(25,25);
                    // ctx.lineTo(105,25);
                    // ctx.lineTo(25,105);
                    // ctx.fill();

                    // 描边三角形
                    // ctx.beginPath();
                    // ctx.moveTo(125,125);
                    // ctx.lineTo(125,45);
                    // ctx.lineTo(45,125);
                    // ctx.closePath();
                    // ctx.stroke();

                    
                    // draws.smileFace(ctx);

                    // var rectangle = new Path2D();
                    // rectangle.rect(10, 10, 50, 50);
                    // var circle = new Path2D();
                    // circle.moveTo(125, 35);
                    // circle.arc(100, 35, 25, 0, 2 * Math.PI);
                    // ctx.stroke(rectangle);
                    // ctx.fill(circle);


                    // //  画背景
                    // ctx.fillStyle = '#FD0';
                    // ctx.fillRect(0,0,75,75);
                    // ctx.fillStyle = '#6C0';
                    // ctx.fillRect(75,0,75,75);
                    // ctx.fillStyle = '#09F';
                    // ctx.fillRect(0,75,75,75);
                    // ctx.fillStyle = '#F30';
                    // ctx.fillRect(75,75,75,75);
                    // ctx.fillStyle = '#FFF';
                    // // 设置透明度值
                    // ctx.globalAlpha = 0.2;
                    // // 画半透明圆
                    // for (var i=0;i<7;i++){
                    //     ctx.beginPath();
                    //     ctx.arc(75,75,10+10*i,0,Math.PI*2,true);
                    //     ctx.fill();
                    // }

                    // // 画背景
                    // ctx.fillStyle = 'rgb(255,221,0)';
                    // ctx.fillRect(0,0,150,37.5);
                    // ctx.fillStyle = 'rgb(102,204,0)';
                    // ctx.fillRect(0,37.5,150,37.5);
                    // ctx.fillStyle = 'rgb(0,153,255)';
                    // ctx.fillRect(0,75,150,37.5);
                    // ctx.fillStyle = 'rgb(255,51,0)';
                    // ctx.fillRect(0,112.5,150,37.5);
                    // // 画半透明矩形
                    // for (var i=0;i<10;i++){
                    //     ctx.fillStyle = 'rgba(255,255,255,'+(i+1)/10+')';
                    //     for (var j=0;j<4;j++){
                    //         ctx.fillRect(5+i*14,5+j*37.5,14,27.5)
                    //     }
                    // }


                    // 创建路径
                    // ctx.strokeStyle = '#09f';
                    // ctx.beginPath();
                    // ctx.moveTo(10,10);
                    // ctx.lineTo(140,10);
                    // ctx.moveTo(10,140);
                    // ctx.lineTo(140,140);
                    // ctx.stroke();
                    // var lineCap = ['butt','round','square'];
                    // ctx.strokeStyle = 'black';
                    // for (var i=0;i<lineCap.length;i++){
                    //     ctx.lineWidth = 15;
                    //     ctx.lineCap = lineCap[i];
                    //     ctx.beginPath();
                    //     ctx.moveTo(25+i*50,10);
                    //     ctx.lineTo(25+i*50,140);
                    //     ctx.stroke();
                    // }

          

                    // var lineJoin = ['round','bevel','miter'];
                    // ctx.lineWidth = 10;
                    // for (var i=0;i<lineJoin.length;i++){
                    //     ctx.lineJoin = lineJoin[i];
                    //     ctx.beginPath();
                    //     ctx.moveTo(-5,5+i*40);
                    //     ctx.lineTo(35,45+i*40);
                    //     ctx.lineTo(75,5+i*40);
                    //     ctx.lineTo(115,45+i*40);
                    //     ctx.lineTo(155,5+i*40);
                    //     ctx.stroke();
                    // }
                
                    // draws.dynamicStrokeLine(ctx,0,0, canvas.width, canvas.height);
                
                    // var lingrad = ctx.createLinearGradient(0,0,0,150);
                    // lingrad.addColorStop(0, '#00ABEB');
                    // lingrad.addColorStop(0.5, '#fff');
                    // lingrad.addColorStop(0.5, '#26C000');
                    // lingrad.addColorStop(1, '#fff');
                    // var lingrad2 = ctx.createLinearGradient(0,50,0,95);
                    // lingrad2.addColorStop(0.5, '#000');
                    // lingrad2.addColorStop(1, 'rgba(0,0,0,0)');
                    // // assign gradients to fill and stroke styles
                    // ctx.fillStyle = lingrad;
                    // ctx.strokeStyle = lingrad2;
                    // // draw shapes
                    // ctx.fillRect(10,10,130,130);
                    // ctx.strokeRect(50,50,50,50);

                    // // 创建渐变
                    // var radgrad = ctx.createRadialGradient(45,45,10,52,50,30);
                    // radgrad.addColorStop(0, '#A7D30C');
                    // radgrad.addColorStop(0.9, '#019F62');
                    // radgrad.addColorStop(1, 'rgba(1,159,98,0)');
                    // var radgrad2 = ctx.createRadialGradient(105,105,20,112,120,50);
                    // radgrad2.addColorStop(0, '#FF5F98');
                    // radgrad2.addColorStop(0.75, '#FF0188');
                    // radgrad2.addColorStop(1, 'rgba(255,1,136,0)');
                    // var radgrad3 = ctx.createRadialGradient(95,15,15,102,20,40);
                    // radgrad3.addColorStop(0, '#00C9FF');
                    // radgrad3.addColorStop(0.8, '#00B5E2');
                    // radgrad3.addColorStop(1, 'rgba(0,201,255,0)');
                    // var radgrad4 = ctx.createRadialGradient(0,150,50,0,140,90);
                    // radgrad4.addColorStop(0, '#F4F201');
                    // radgrad4.addColorStop(0.8, '#E4C700');
                    // radgrad4.addColorStop(1, 'rgba(228,199,0,0)');
                    // // 画图形
                    // ctx.fillStyle = radgrad4;
                    // ctx.fillRect(0,0,150,150);
                    // ctx.fillStyle = radgrad3;
                    // ctx.fillRect(0,0,150,150);
                    // ctx.fillStyle = radgrad2;
                    // ctx.fillRect(0,0,150,150);
                    // ctx.fillStyle = radgrad;
                    // ctx.fillRect(0,0,150,150);



                    // ctx.beginPath(); 
                    // ctx.arc(50, 50, 30, 0, Math.PI*2, true);
                    // ctx.arc(50, 50, 15, 0, Math.PI*2, true);
                    // ctx.fill("evenodd");


                    // ctx.font = "48px serif";
                    // ctx.save();
                    // ctx.shadowOffsetX = 2;
                    // ctx.shadowOffsetY = 2;
                    // ctx.shadowBlur = 2;
                    // ctx.shadowColor = "rgba(0, 0, 0, 0.5)";
                    // ctx.fillStyle = "Black";
                    // ctx.fillText("Hello world", 10, 50);
                    // ctx.restore();
                    // ctx.textAlign = "start";//start, end, left, right, center
                    // ctx.textBaseline = "alphabetic"; //top, hanging, middle, alphabetic, ideographic, bottom
                    // ctx.direction = "ltr";//ltr, rtl, inherit
                    // ctx.strokeText("Hello world", 10, 150);
                    // var text = ctx.measureText("foo");
                    // console.log(text);


                    // 创建新 image 对象，用作图案
                    // var img = new Image();
                    // img.src = 'assets/picture.jpg';
                    // img.onload = function(){
                    //     // 创建图案
                    //     var ptrn = ctx.createPattern(img,'no-repeat'); //repeat, repeat-x, repeat-y, no-repeat
                    //     ctx.fillStyle = ptrn;
                    //     ctx.fillRect(0,0,500,500);
                    // }

                    // // ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight)
                    // var img = new Image();
                    // img.src = 'https://mdn.mozillademos.org/files/5397/rhino.jpg';
                    // img.onload = function(){
                    //     for (var i=0;i<4;i++){
                    //         for (var j=0;j<3;j++){
                    //             ctx.drawImage(img,j*50,i*38,50,38);
                    //         }
                    //     }
                    // };
                    
                    // ctx.fillRect(0,0,150,150);   // 使用默认设置绘制一个矩形
                    // ctx.save();                  // 保存默认状态
                    // ctx.fillStyle = '#09F'       // 在原有配置基础上对颜色做改变
                    // ctx.fillRect(15,15,120,120); // 使用新的设置绘制一个矩形
                    // ctx.save();                  // 保存当前状态
                    // ctx.fillStyle = '#FFF'       // 再次改变颜色配置
                    // ctx.globalAlpha = 0.5;    
                    // ctx.fillRect(30,30,90,90);   // 使用新的配置绘制一个矩形
                    // ctx.restore();               // 重新加载之前的颜色状态
                    // ctx.fillRect(45,45,60,60);   // 使用上一次的配置绘制一个矩形
                    // ctx.restore();               // 加载默认颜色配置
                    // ctx.fillRect(60,60,30,30);   // 使用加载的配置绘制一个矩形


                    // ctx.translate(75,75);
                    // for (var i=1;i<6;i++){ // Loop through rings (from inside to out)
                    //     ctx.save();
                    //     ctx.fillStyle = 'rgb('+(51*i)+','+(255-51*i)+',255)';
                    //     for (var j=0;j<i*6;j++){ // draw individual dots
                    //         ctx.rotate(Math.PI*2/(i*6));
                    //         ctx.beginPath();
                    //         ctx.arc(0,i*12.5,5,0,Math.PI*2,true);
                    //         ctx.fill();
                    //     }
                    //     ctx.restore();
                    // }


                    // draws.roundedRect(ctx,12,12,150,150,15);

                    // for (var i=0;i<3;i++) {
                    //     for (var j=0;j<3;j++) {
                    //         ctx.save();
                    //         ctx.strokeStyle = "#9CFF00";
                    //         ctx.translate(50+j*100,50+i*100);
                    //         draws.drawSpirograph(ctx,20*(j+2)/(j+1),-8*(i+3)/(i+1),10);
                    //         ctx.restore();
                    //     }
                    // }

                    // ctx.strokeStyle = "#fc0";
                    // ctx.lineWidth = 1.5;
                    // ctx.fillRect(0,0,300,300);
                    // // Uniform scaling
                    // ctx.save()
                    // ctx.translate(50,50);
                    // draws.drawSpirograph(ctx,22,6,5);  // no scaling
                    // ctx.translate(100,0);
                    // ctx.scale(0.75,0.75);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.translate(133.333,0);
                    // ctx.scale(0.75,0.75);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.restore();
                    // // Non-uniform scaling (y direction)
                    // ctx.strokeStyle = "#0cf";
                    // ctx.save()
                    // ctx.translate(50,150);
                    // ctx.scale(1,0.75);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.translate(100,0);
                    // ctx.scale(1,0.75);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.translate(100,0);
                    // ctx.scale(1,0.75);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.restore();
                    // // Non-uniform scaling (x direction)
                    // ctx.strokeStyle = "#cf0";
                    // ctx.save()
                    // ctx.translate(50,250);
                    // ctx.scale(0.75,1);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.translate(133.333,0);
                    // ctx.scale(0.75,1);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.translate(177.777,0);
                    // ctx.scale(0.75,1);
                    // draws.drawSpirograph(ctx,22,6,5);
                    // ctx.restore();


                    // ctx.fillRect(0,0,150,150);
                    // ctx.translate(75,75);
                    // // Create a circular clipping path
                    // ctx.beginPath();
                    // ctx.arc(0,0,60,0,Math.PI*2,true);
                    // ctx.clip();
                    // // draw background
                    // var lingrad = ctx.createLinearGradient(0,-75,0,75);
                    // lingrad.addColorStop(0, '#232256');
                    // lingrad.addColorStop(1, '#143778');
                    // ctx.fillStyle = lingrad;
                    // ctx.fillRect(-75,-75,150,150);
                    // // draw stars
                    // for (var j=1;j<50;j++){
                    //     ctx.save();
                    //     ctx.fillStyle = '#fff';
                    //     ctx.translate(75-Math.floor(Math.random()*150),75-Math.floor(Math.random()*150));
                    //     draws.drawStar(ctx,Math.floor(Math.random()*4)+2);
                    //     ctx.restore();
                    // }
        


                }());
            };
        </script>
    </body>
</html>